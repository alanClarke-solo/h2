// Complete DatabaseCacheProvider.java
package ac.h2;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.sql.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;
import java.util.stream.Collectors;

public class DatabaseCacheProvider<T> {
    // Updated table schema with NUMBER primary key and BLOB for binary data
    private static final String CREATE_CACHE_TABLE = """
    DECLARE
        table_exists NUMBER;
    BEGIN
        SELECT COUNT(*) INTO table_exists 
        FROM user_tables 
        WHERE table_name = 'HIERARCHICAL_CACHE';
        
        IF table_exists = 0 THEN
            EXECUTE IMMEDIATE 'CREATE TABLE hierarchical_cache (
                id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                unique_string_id VARCHAR2(500) UNIQUE NOT NULL,
                string_key VARCHAR2(200),
                long_key NUMBER(19),
                value_data BLOB,
                value_type VARCHAR2(200),
                parameters CLOB,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                ttl_millis NUMBER(19),
                expires_at TIMESTAMP
            )';
            
            -- Remove this line - unique constraint already creates an index
            -- EXECUTE IMMEDIATE 'CREATE INDEX idx_cache_unique_string ON hierarchical_cache(unique_string_id)';
            EXECUTE IMMEDIATE 'CREATE INDEX idx_cache_string_key ON hierarchical_cache(string_key)';
            EXECUTE IMMEDIATE 'CREATE INDEX idx_cache_long_key ON hierarchical_cache(long_key)';
        END IF;
    END;
    """;

    private static final String CREATE_PARAM_INDEX_TABLE = """
    DECLARE
        table_exists NUMBER;
    BEGIN
        SELECT COUNT(*) INTO table_exists 
        FROM user_tables 
        WHERE table_name = 'CACHE_PARAM_INDEX';
        
        IF table_exists = 0 THEN
            EXECUTE IMMEDIATE 'CREATE TABLE cache_param_index (
                id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                param_pattern VARCHAR2(1000),
                unique_string_id VARCHAR2(500),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                CONSTRAINT uk_param_unique UNIQUE (param_pattern, unique_string_id)
            )';
            
            EXECUTE IMMEDIATE 'CREATE INDEX idx_param_pattern ON cache_param_index(param_pattern)';
            EXECUTE IMMEDIATE 'CREATE INDEX idx_param_unique_id ON cache_param_index(unique_string_id)';
        END IF;
    END;
    """;

    private static final String INSERT_CACHE_ITEM = """
        MERGE INTO hierarchical_cache hc
        USING (SELECT ? as unique_string_id FROM dual) src
        ON (hc.unique_string_id = src.unique_string_id)
        WHEN MATCHED THEN
            UPDATE SET string_key = ?, long_key = ?, value_data = ?, value_type = ?, 
                      parameters = ?, created_at = CURRENT_TIMESTAMP, ttl_millis = ?, 
                      expires_at = CASE WHEN ? > 0 THEN CURRENT_TIMESTAMP + INTERVAL '1' SECOND * (? / 1000) ELSE NULL END
        WHEN NOT MATCHED THEN
            INSERT (unique_string_id, string_key, long_key, value_data, value_type, parameters, ttl_millis, expires_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, CASE WHEN ? > 0 THEN CURRENT_TIMESTAMP + INTERVAL '1' SECOND * (? / 1000) ELSE NULL END)
        """;

    private static final String SELECT_BY_UNIQUE_ID = """
        SELECT * FROM hierarchical_cache 
        WHERE unique_string_id = ? AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)
        """;

    private static final String SELECT_BY_STRING_KEY = """
        SELECT * FROM hierarchical_cache 
        WHERE string_key = ? AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)
        """;

    private static final String SELECT_BY_LONG_KEY = """
        SELECT * FROM hierarchical_cache 
        WHERE long_key = ? AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)
        """;

    private static final String DELETE_BY_UNIQUE_ID = "DELETE FROM hierarchical_cache WHERE unique_string_id = ?";
    private static final String DELETE_PARAM_BY_UNIQUE_ID = "DELETE FROM cache_param_index WHERE unique_string_id = ?";
    private static final String DELETE_ALL_CACHE = "DELETE FROM hierarchical_cache";
    private static final String DELETE_ALL_PARAMS = "DELETE FROM cache_param_index";

    private final HikariDataSource dataSource;
    private final ThreadLocal<Kryo> kryoThreadLocal;
    private final Map<Class<?>, Boolean> registeredClasses = new ConcurrentHashMap<>();
    private final long defaultTtlMillis;
    private final CacheStatistics statistics;

    public DatabaseCacheProvider(String jdbcUrl, String username, String password) {
        this(jdbcUrl, username, password, 300000L); // 5 minutes default TTL
    }

    public DatabaseCacheProvider(String jdbcUrl, String username, String password, long defaultTtlMillis) {
        // Initialize HikariCP
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(jdbcUrl);
        config.setUsername(username);
        config.setPassword(password);
        config.setMaximumPoolSize(20);
        config.setMinimumIdle(5);
        config.setConnectionTimeout(30000);
        config.setIdleTimeout(600000);
        config.setMaxLifetime(1800000);

        this.dataSource = new HikariDataSource(config);
        this.defaultTtlMillis = defaultTtlMillis;
        this.statistics = new CacheStatistics();

        // Initialize Kryo ThreadLocal
        this.kryoThreadLocal = ThreadLocal.withInitial(() -> {
            Kryo kryo = new Kryo();
            kryo.setReferences(true);
            kryo.setRegistrationRequired(false);
            // Pre-register common classes
            kryo.register(String.class);
            kryo.register(ArrayList.class);
            kryo.register(HashMap.class);
            kryo.register(SearchParameter.class);
            kryo.register(CachedItem.class);
            return kryo;
        });

        initializeTables();
    }

    private void initializeTables() {
        try (Connection conn = dataSource.getConnection()) {
            try (PreparedStatement stmt1 = conn.prepareStatement(CREATE_CACHE_TABLE);
                 PreparedStatement stmt2 = conn.prepareStatement(CREATE_PARAM_INDEX_TABLE)) {
                stmt1.execute();
                stmt2.execute();
            }
        } catch (SQLException e) {
            throw new RuntimeException("Failed to initialize database tables", e);
        }
    }

    // ==================== SERIALIZATION METHODS ====================

    private byte[] serializeValue(T value) {
        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
             Output output = new Output(baos)) {

            Kryo kryo = kryoThreadLocal.get();
            Class<?> valueClass = value.getClass();
            if (!registeredClasses.containsKey(valueClass)) {
                kryo.register(valueClass);
                registeredClasses.put(valueClass, true);
            }

            kryo.writeObject(output, value);
            output.flush();
            return baos.toByteArray();

        } catch (Exception e) {
            throw new RuntimeException("Failed to serialize value using Kryo", e);
        }
    }

    private T deserializeValue(byte[] data, Class<T> valueType) {
        if (data == null) return null;

        try (ByteArrayInputStream bais = new ByteArrayInputStream(data);
             Input input = new Input(bais)) {

            Kryo kryo = kryoThreadLocal.get();
            if (!registeredClasses.containsKey(valueType)) {
                kryo.register(valueType);
                registeredClasses.put(valueType, true);
            }

            return kryo.readObject(input, valueType);

        } catch (Exception e) {
            throw new RuntimeException("Failed to deserialize value using Kryo", e);
        }
    }

    // ==================== PUT OPERATIONS ====================

    public void put(String key, List<SearchParameter> parameters, T value) {
        put(key, null, parameters, value, defaultTtlMillis);
    }

    public void put(String key, List<SearchParameter> parameters, T value, long ttlMillis) {
        put(key, null, parameters, value, ttlMillis);
    }

    public void put(String key, Long id, List<SearchParameter> parameters, T value) {
        put(key, id, parameters, value, defaultTtlMillis);
    }

    public void put(String key, Long id, List<SearchParameter> parameters, T value, long ttlMillis) {
        if (key == null || parameters == null || value == null) {
            throw new IllegalArgumentException("Key, parameters, and value cannot be null");
        }

        CachedItem<T> cachedItem = new CachedItem<>(key, id, value, parameters, ttlMillis);
        String uniqueStringId = cachedItem.generateUniqueId();

        try (Connection conn = dataSource.getConnection()) {
            conn.setAutoCommit(false);

            try {
                // Serialize value and parameters
                byte[] serializedValue = serializeValue(value);
                byte[] serializedParameters = serializeParameters(parameters);
                String parametersBase64 = Base64.getEncoder().encodeToString(serializedParameters);

                // Insert/update main cache item
                try (PreparedStatement stmt = conn.prepareStatement(INSERT_CACHE_ITEM)) {
                    // MERGE parameters
                    stmt.setString(1, uniqueStringId);   // USING clause
                    stmt.setString(2, key);              // WHEN MATCHED UPDATE
                    if (id != null) {
                        stmt.setLong(3, id);
                    } else {
                        stmt.setNull(3, Types.BIGINT);
                    }
                    stmt.setBytes(4, serializedValue);
                    stmt.setString(5, value.getClass().getName());
                    stmt.setString(6, parametersBase64);
                    stmt.setLong(7, ttlMillis);
                    stmt.setLong(8, ttlMillis);
                    stmt.setLong(9, ttlMillis);

                    // WHEN NOT MATCHED INSERT parameters
                    stmt.setString(10, uniqueStringId);
                    stmt.setString(11, key);
                    if (id != null) {
                        stmt.setLong(12, id);
                    } else {
                        stmt.setNull(12, Types.BIGINT);
                    }
                    stmt.setBytes(13, serializedValue);
                    stmt.setString(14, value.getClass().getName());
                    stmt.setString(15, parametersBase64);
                    stmt.setLong(16, ttlMillis);
                    stmt.setLong(17, ttlMillis);
                    stmt.setLong(18, ttlMillis);

                    stmt.executeUpdate();
                }

                // Clean up old parameter indexes
                try (PreparedStatement deleteStmt = conn.prepareStatement(DELETE_PARAM_BY_UNIQUE_ID)) {
                    deleteStmt.setString(1, uniqueStringId);
                    deleteStmt.executeUpdate();
                }

                // Insert new parameter indexes
                Set<String> patterns = generateHierarchicalPatterns(parameters);
                for (String pattern : patterns) {
                    try (PreparedStatement stmt = conn.prepareStatement(
                            "INSERT INTO cache_param_index (param_pattern, unique_string_id) VALUES (?, ?)")) {
                        stmt.setString(1, pattern);
                        stmt.setString(2, uniqueStringId);
                        stmt.executeUpdate();
                    }
                }

                conn.commit();
                statistics.incrementValues();
                statistics.incrementKeys();

            } catch (Exception e) {
                conn.rollback();
                throw e;
            }
        } catch (Exception e) {
            throw new RuntimeException("Failed to store item in database", e);
        }
    }

    private byte[] serializeParameters(List<SearchParameter> parameters) {
        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
             Output output = new Output(baos)) {

            Kryo kryo = kryoThreadLocal.get();
            kryo.writeObject(output, parameters);
            output.flush();
            return baos.toByteArray();

        } catch (Exception e) {
            throw new RuntimeException("Failed to serialize parameters using Kryo", e);
        }
    }

    // ==================== GET OPERATIONS ====================

    public Optional<T> get(String key, Class<T> valueType) {
        if (key == null) return Optional.empty();

        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(SELECT_BY_STRING_KEY)) {

            stmt.setString(1, key);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    byte[] valueData = rs.getBytes("value_data");
                    T value = deserializeValue(valueData, valueType);
                    statistics.incrementHits();
                    return Optional.of(value);
                }
            }
        } catch (Exception e) {
            throw new RuntimeException("Failed to get item from database", e);
        }

        statistics.incrementMisses();
        return Optional.empty();
    }

    public Optional<T> get(Long id, Class<T> valueType) {
        if (id == null) return Optional.empty();

        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(SELECT_BY_LONG_KEY)) {

            stmt.setLong(1, id);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    byte[] valueData = rs.getBytes("value_data");
                    T value = deserializeValue(valueData, valueType);
                    statistics.incrementHits();
                    return Optional.of(value);
                }
            }
        } catch (Exception e) {
            throw new RuntimeException("Failed to get item from database", e);
        }

        statistics.incrementMisses();
        return Optional.empty();
    }

    public Optional<T> get(String key, Long id, Class<T> valueType) {
        if (key == null || id == null) return Optional.empty();

        String uniqueStringId = key + ":" + id;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(SELECT_BY_UNIQUE_ID)) {

            stmt.setString(1, uniqueStringId);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    byte[] valueData = rs.getBytes("value_data");
                    T value = deserializeValue(valueData, valueType);
                    statistics.incrementHits();
                    return Optional.of(value);
                }
            }
        } catch (Exception e) {
            throw new RuntimeException("Failed to get item from database", e);
        }

        statistics.incrementMisses();
        return Optional.empty();
    }

    public List<T> get(List<SearchParameter> parameters, Class<T> valueType) {
        if (parameters == null || parameters.isEmpty()) {
            statistics.incrementMisses();
            return Collections.emptyList();
        }

        Set<String> patterns = generateHierarchicalPatterns(parameters);
        Set<String> uniqueIds = new HashSet<>();

        try (Connection conn = dataSource.getConnection()) {
            // Get unique IDs matching patterns
            if (!patterns.isEmpty()) {
                String placeholders = patterns.stream().map(p -> "?").collect(Collectors.joining(","));
                String query = "SELECT DISTINCT unique_string_id FROM cache_param_index WHERE param_pattern IN (" + placeholders + ")";

                try (PreparedStatement stmt = conn.prepareStatement(query)) {
                    int paramIndex = 1;
                    for (String pattern : patterns) {
                        stmt.setString(paramIndex++, pattern);
                    }

                    try (ResultSet rs = stmt.executeQuery()) {
                        while (rs.next()) {
                            uniqueIds.add(rs.getString("unique_string_id"));
                        }
                    }
                }
            }

            // Fetch actual values
            List<T> results = new ArrayList<>();
            if (!uniqueIds.isEmpty()) {
                String placeholders = uniqueIds.stream().map(id -> "?").collect(Collectors.joining(","));
                String valueQuery = "SELECT value_data FROM hierarchical_cache WHERE unique_string_id IN (" + placeholders +
                        ") AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)";

                try (PreparedStatement stmt = conn.prepareStatement(valueQuery)) {
                    int paramIndex = 1;
                    for (String uniqueId : uniqueIds) {
                        stmt.setString(paramIndex++, uniqueId);
                    }

                    try (ResultSet rs = stmt.executeQuery()) {
                        while (rs.next()) {
                            byte[] valueData = rs.getBytes("value_data");
                            T value = deserializeValue(valueData, valueType);
                            results.add(value);
                        }
                    }
                }
            }

            if (results.isEmpty()) {
                statistics.incrementMisses();
            } else {
                statistics.incrementHits();
            }

            return results;
        } catch (Exception e) {
            throw new RuntimeException("Failed to search items in database", e);
        }
    }

    // ==================== LINK OPERATIONS ====================

    public void link(String key, Long id) {
        if (key == null || id == null) {
            throw new IllegalArgumentException("Key and id cannot be null");
        }

        // Check if key exists
        Optional<CachedItemInfo> existingItem = getCachedItemInfo(key, null);
        if (!existingItem.isPresent()) {
            throw new IllegalStateException("No cached item found for key: " + key);
        }
        // Check if key already has an ID
        if (existingItem.get().longKey != null) {
            throw new IllegalStateException("Key " + key + " already has an associated ID");
        }

        // Check if ID is already used
//        if (get(id, String.class).isPresent()) {
//            throw new IllegalStateException("ID " + id + " is already associated with another key");
//        }
        // Update the record with new ID
        updateItemWithId(existingItem.get().uniqueStringId, id);
    }

    public void link(String key, List<SearchParameter> parameters) {
        if (key == null || parameters == null || parameters.isEmpty()) {
            throw new IllegalArgumentException("Key and parameters cannot be null or empty");
        }

        Optional<CachedItemInfo> existingItem = getCachedItemInfo(key, null);
        if (!existingItem.isPresent()) {
            throw new IllegalStateException("No cached item found for key: " + key);
        }

        // Add new parameter patterns
        addParameterPatterns(existingItem.get().uniqueStringId, parameters);
    }

    public void link(Long id, List<SearchParameter> parameters) {
        if (id == null || parameters == null || parameters.isEmpty()) {
            throw new IllegalArgumentException("ID and parameters cannot be null or empty");
        }

        Optional<CachedItemInfo> existingItem = getCachedItemInfo(null, id);
        if (!existingItem.isPresent()) {
            throw new IllegalStateException("No cached item found for ID: " + id);
        }

        // Add new parameter patterns
        addParameterPatterns(existingItem.get().uniqueStringId, parameters);
    }

    // ==================== GET OR COMPUTE OPERATIONS ====================

    public T getOrCompute(String key, Class<T> valueType, Supplier<T> supplier) {
        Optional<T> cached = get(key, valueType);
        if (cached.isPresent()) {
            return cached.get();
        }

        T computed = supplier.get();
        if (computed != null) {
            put(key, Collections.emptyList(), computed);
        }
        return computed;
    }

    public T getOrCompute(String key, Long id, Class<T> valueType, Supplier<T> supplier) {
        Optional<T> cached = get(key, id, valueType);
        if (cached.isPresent()) {
            return cached.get();
        }

        T computed = supplier.get();
        if (computed != null) {
            put(key, id, Collections.emptyList(), computed);
        }
        return computed;
    }

    public T getOrCompute(Long id, Class<T> valueType, Supplier<T> supplier) {
        Optional<T> cached = get(id, valueType);
        if (cached.isPresent()) {
            return cached.get();
        }

        T computed = supplier.get();
        if (computed != null) {
            throw new IllegalStateException("Cannot cache item with only Long ID - string key required");
        }
        return computed;
    }

    public List<T> getOrCompute(List<SearchParameter> parameters, Class<T> valueType, Supplier<List<T>> supplier) {
        List<T> cached = get(parameters, valueType);
        if (!cached.isEmpty()) {
            return cached;
        }

        List<T> computed = supplier.get();
        return computed != null ? computed : Collections.emptyList();
    }

    // ==================== INVALIDATION OPERATIONS ====================

    public void invalidate(String key) {
        if (key == null) return;

        try (Connection conn = dataSource.getConnection()) {
            conn.setAutoCommit(false);

            try {
                // Find unique IDs to remove
                Set<String> uniqueIdsToRemove = new HashSet<>();
                String selectSql = "SELECT unique_string_id FROM hierarchical_cache WHERE string_key = ?";

                try (PreparedStatement selectStmt = conn.prepareStatement(selectSql)) {
                    selectStmt.setString(1, key);
                    try (ResultSet rs = selectStmt.executeQuery()) {
                        while (rs.next()) {
                            uniqueIdsToRemove.add(rs.getString("unique_string_id"));
                        }
                    }
                }

                // Delete from both tables
                for (String uniqueId : uniqueIdsToRemove) {
                    invalidateByUniqueId(conn, uniqueId);
                }

                conn.commit();
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            } finally {
                conn.setAutoCommit(true);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Failed to invalidate key in database", e);
        }
    }

    public void invalidate(Long id) {
        if (id == null) return;

        try (Connection conn = dataSource.getConnection()) {
            conn.setAutoCommit(false);

            try {
                // Find unique IDs to remove
                Set<String> uniqueIdsToRemove = new HashSet<>();
                String selectSql = "SELECT unique_string_id FROM hierarchical_cache WHERE long_key = ?";

                try (PreparedStatement selectStmt = conn.prepareStatement(selectSql)) {
                    selectStmt.setLong(1, id);
                    try (ResultSet rs = selectStmt.executeQuery()) {
                        while (rs.next()) {
                            uniqueIdsToRemove.add(rs.getString("unique_string_id"));
                        }
                    }
                }

                // Delete from both tables
                for (String uniqueId : uniqueIdsToRemove) {
                    invalidateByUniqueId(conn, uniqueId);
                }

                conn.commit();
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            } finally {
                conn.setAutoCommit(true);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Failed to invalidate ID in database", e);
        }
    }

    public void invalidate(String key, Long id) {
        if (key == null || id == null) return;

        String uniqueStringId = key + ":" + id;
        try (Connection conn = dataSource.getConnection()) {
            conn.setAutoCommit(false);

            try {
                invalidateByUniqueId(conn, uniqueStringId);
                conn.commit();
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            } finally {
                conn.setAutoCommit(true);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Failed to invalidate specific item in database", e);
        }
    }

    public void invalidateAll() {
        try (Connection conn = dataSource.getConnection()) {
            conn.setAutoCommit(false);

            try (PreparedStatement stmt1 = conn.prepareStatement(DELETE_ALL_PARAMS);
                 PreparedStatement stmt2 = conn.prepareStatement(DELETE_ALL_CACHE)) {

                stmt1.executeUpdate();
                stmt2.executeUpdate();
                conn.commit();

                // Reset statistics
                statistics.reset();

            } catch (SQLException e) {
                conn.rollback();
                throw e;
            } finally {
                conn.setAutoCommit(true);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Failed to invalidate all items in database", e);
        }
    }

    // ==================== UTILITY METHODS ====================

    private void invalidateByUniqueId(Connection conn, String uniqueId) throws SQLException {
        // Delete from parameter index
        try (PreparedStatement stmt = conn.prepareStatement(DELETE_PARAM_BY_UNIQUE_ID)) {
            stmt.setString(1, uniqueId);
            stmt.executeUpdate();
        }

        // Delete from main cache
        try (PreparedStatement stmt = conn.prepareStatement(DELETE_BY_UNIQUE_ID)) {
            stmt.setString(1, uniqueId);
            int deleted = stmt.executeUpdate();
            if (deleted > 0) {
                statistics.decrementValues();
                statistics.decrementKeys();
            }
        }
    }

    private static class CachedItemInfo {
        final String uniqueStringId;
        final String stringKey;
        final Long longKey;

        CachedItemInfo(String uniqueStringId, String stringKey, Long longKey) {
            this.uniqueStringId = uniqueStringId;
            this.stringKey = stringKey;
            this.longKey = longKey;
        }
    }

    private Optional<CachedItemInfo> getCachedItemInfo(String key, Long id) {
        String query;
        if (key != null) {
            query = "SELECT unique_string_id, string_key, long_key FROM hierarchical_cache WHERE string_key = ?";
        } else {
            query = "SELECT unique_string_id, string_key, long_key FROM hierarchical_cache WHERE long_key = ?";
        }

        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(query)) {

            if (key != null) {
                stmt.setString(1, key);
            } else {
                stmt.setLong(1, id);
            }

            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return Optional.of(new CachedItemInfo(
                            rs.getString("unique_string_id"),
                            rs.getString("string_key"),
                            rs.getObject("long_key", Long.class)
                    ));
                }
            }
        } catch (SQLException e) {
            throw new RuntimeException("Failed to get cached item info", e);
        }

        return Optional.empty();
    }

    private void updateItemWithId(String uniqueStringId, Long newId) {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                     "UPDATE hierarchical_cache SET long_key = ? WHERE unique_string_id = ?")) {

            stmt.setLong(1, newId);
            stmt.setString(2, uniqueStringId);
            stmt.executeUpdate();

        } catch (SQLException e) {
            throw new RuntimeException("Failed to update item with ID", e);
        }
    }

    private void addParameterPatterns(String uniqueStringId, List<SearchParameter> parameters) {
        Set<String> newPatterns = generateHierarchicalPatterns(parameters);

        try (Connection conn = dataSource.getConnection()) {
            for (String pattern : newPatterns) {
                try (PreparedStatement stmt = conn.prepareStatement(
                        "INSERT INTO cache_param_index (param_pattern, unique_string_id) VALUES (?, ?)")) {
                    stmt.setString(1, pattern);
                    stmt.setString(2, uniqueStringId);
                    try {
                        stmt.executeUpdate();
                    } catch (SQLException e) {
                        // Ignore duplicate key errors - pattern might already exist
                        if (!e.getMessage().contains("unique constraint")) {
                            throw e;
                        }
                    }
                }
            }
        } catch (SQLException e) {
            throw new RuntimeException("Failed to add parameter patterns", e);
        }
    }

    private Set<String> generateHierarchicalPatterns(List<SearchParameter> parameters) {
        if (parameters == null || parameters.isEmpty()) {
            return Collections.emptySet();
        }

        List<SearchParameter> sortedParams = parameters.stream()
                .sorted(Comparator.comparingInt(SearchParameter::getLevel))
                .collect(Collectors.toList());

        Set<String> patterns = new HashSet<>();

        // Generate all possible combinations maintaining hierarchy
        for (int i = 0; i < sortedParams.size(); i++) {
            for (int j = i; j < sortedParams.size(); j++) {
                List<SearchParameter> subList = sortedParams.subList(i, j + 1);
                String pattern = subList.stream()
                        .map(SearchParameter::toKey)
                        .collect(Collectors.joining(">"));
                patterns.add(pattern);
            }
        }

        // Add individual parameter patterns
        for (SearchParameter param : sortedParams) {
            patterns.add(param.toKey());
        }

        return patterns;
    }

    public CacheStatistics getStatistics() {
        return statistics;
    }

    public void shutdown() {
        if (dataSource != null && !dataSource.isClosed()) {
            dataSource.close();
        }
    }
}